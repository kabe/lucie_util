#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use Data::Dumper;

# Debug ?
my $DEBUG = 1;

###################################################################
#################### CONFIGURATION BEGINS HERE ####################
###################################################################

my $ldb_repos = q|/home/kabe/git/L4|;
my $secret_file = q|~/lucie/env.enc|;
my $remote_ldb_repository_type = q|Subversion|;
my $remote_ldb_repository = q|svn+ssh://intri@www.intrigger.jp/home/intri/SVN/L4|;

###################################################################
##################### CONFIGURATION ENDS HERE #####################
###################################################################

# Templates
my $cluster_select_sql = q|select name, install_mac, install_netmask, install_address, storage_conf_type, arch from host where name>="START_NODE" and name<="END_NODE"|;
my $line_tmpl = q|NODENAME --mac MAC --storage-conf STORAGE_CONF --ip-address IP_ADDRESS --netmask NETMASK|;
my $glbl_tmpl = <<'END';
#/bin/sh

./node install-multi \
LINE_TMPLS
--source-control REMOTE_LDB_REPOSITORY_TYPE \
--ldb-repository REMOTE_LDB_REPOSITORY_LOCATION \
--verbose \
-i INSTALL_KERNEL \
-l LINUX_KERNEL \
--secret SECRET_FILE
END

# Usage
sub usage {
  print << "EOD";
Usage :
 \$ $0 --start-node S_NODE --end-node E_NODE --exclude EXCLUDE1 EXCLUDE2 ...

  S_NODE   : NODE FROM (e.g. hongo100)
  E_NODE   : NODE TO   (e.g. hongo402)
  EXCLUDEn : NODEs to be excluded from the range (e.g. hongo105 hongo107)

Run Example :
 \$ $0 --start-node sheep00 --end-node sheep64 --exclude sheep02 sheep04 sheep07 sheep34 sheep46 sheep47

EOD
}

# Setup
my $storage_dir = $ldb_repos . q|/lucie/storage|;
my $check_secret_file = 1;
if ($DEBUG) {
  $check_secret_file = 0;
}

# Util
sub error{
  my $error_type = shift;
  my $additional_message = shift | '';
  my $tmpl;
  if (!defined $error_type) {
    $tmpl = q|Undefined|;
  } elsif ($error_type == 1) { # inconsistent
    $tmpl = q|Inconsistent|;
  } elsif ($error_type == 2) { # notfound
    $tmpl = q|NOTFOUND|;
  } else {
    $tmpl = q|Unknown|;
  }

  printf STDERR q|!!! ERROR !!! %s : %s|, $tmpl, $additional_message;
  exit(1);
}

sub get_nodeinfo {
  my $line = shift;
  chomp $line;
  my ($name, $inst_mac, $inst_netmask, $inst_addr, $storage_type, $arch) = split(/\|/, $line);
  error(undef, qq|Column not found|) if $name eq "";
  error(undef, qq|install_mac for $name|) if $inst_mac eq "";
  error(undef, qq|install_netmask for $name|) if $inst_netmask eq "";
  error(undef, qq|install_address for $name|) if $inst_addr eq "";
  error(undef, qq|storage_type for $name|) if $storage_type eq "";
  error(undef, qq|arch for $name|) if $arch eq "";
  return ($name, $inst_mac, $inst_netmask, $storage_type, $arch);
}

sub sql_cmd {
  my $hash = shift;
  my $start_node = $hash->{START_NODE};
  my $end_node = $hash->{END_NODE};
  my $repos = $ldb_repos;
  my $suf = q|bin/ldb sql|;
  $cluster_select_sql =~ s/'/\\'/;
  my $cmd = qq|$repos/$suf '$cluster_select_sql'|;
  $cmd =~ s/START_NODE/$start_node/;
  $cmd =~ s/END_NODE/$end_node/;
  return $cmd;
}

sub node_lines {
  my $aref = shift;
  my $str = "";
  for my $line (@$aref) {
    $str .= $line;
  }
  return $str;
}

# Check storage.conf's existence
# Return "OK" if everything is OK
sub check_storage {
  my $storage_type = shift; # Reference to the list of the names of storage.conf
  # File existence
  my $storage_conf_file_path = $storage_dir . '/' . $storage_type;
  if (! -f qq|$storage_conf_file_path|) {
    return qq|Storage configuration file ($storage_conf_file_path) not exists!|;
  }
  return (q|OK|, $storage_conf_file_path);
}

sub check_netmask {
  my $nref = shift;
  my @s = sort @$nref;
  if (!defined $s[0]) {
    return q|Install Netmask for some node(s) undefined!|;
  }
  if ($s[0] ne $s[$#s]) {
    return q|Some of the install netmask configuration differs!|;
  }
  return (q|OK|, $s[0]);
}

sub check_arch {
  my $aref = shift;
  my @s = sort @$aref;
  if (!defined $s[0]) {
    return q|Install Kernel for some node(s) undefined!|;
  }
  if ($s[0] ne $s[$#s]) {
    return q|Some of the arch configuration differs!|;
  }
  return q|OK|;
}

sub select_install_kernel {
  my $arch = shift;
  if ($arch eq 'x86_64') {
    return q|linux-image-2.6.18_hongo.installer.20090714_amd64.deb|;
  } elsif ($arch eq 'i686') {
    return q|linux-image-2.6.18-fai-kernels_1_i386.deb|;
  } else {
    return q||;
  }
}

sub select_linux_kernel {
  my $arch = shift;
  if ($arch eq 'x86_64') {
    return q|linux-image-amd64|;
  } elsif ($arch eq 'i686') {
    return q|linux-image-686|;
  } else {
    return q||;
  }
}

sub get_ip_address {
  my $name = shift;
  my $netmask = shift;
  my $mac = shift;
  my $sql_tmpl = q|select IP_ADDRESS, NETMASK, MAC_ADDRESS from host where name="NAME"|;
  # Trials
  my %trials = (
                global0 => qw(global_address global_netmask global_mac0),
                global1 => qw(global_address global_netmask global_mac1),
                private => qw(private_address private_netmask private_mac),
                mgmt => qw(mgmt_address mgmt_netmask mgmt_mac),
                mgmt2 => qw(mgmt2_address mgmt2_netmask mgmt2_mac),
               );
  for my $nw_type (keys %trials) {
    my $tmpl = $sql_tmpl;
    $tmpl =~ s/IP_ADDRESS/$trials{nw_type}[0]/;
    $tmpl =~ s/NETMASK/$trials{nw_type}[0]/;
    $tmpl =~ s/MAC_ADDRESS/$trials{nw_type}[0]/;
    if ($DEBUG) { print $tmpl, $/; }
    my $handle = undef;
    open $handle, $tmpl . " | " or die "Can't execute SQL";
    my $line = <$handle>; # Should be only one line
    close $handle;
    my ($t_ip, $t_nm, $t_mac) = split(/,/, $line);
    if ($t_nm eq $netmask and $t_mac eq $mac) {
      return $t_ip;
    }
  }
  return undef;
}

sub main {
  my $hash = shift;
  my @node_lines = ();
  my @mac_unknown = ();
  my @excluded = ();
  my @install_netmask_list = ();
  my @archs = ();
  my $handle = undef;
  # Create SQL Command
  open $handle, sql_cmd($hash) . " | " or die "Can't open L4 pipe";
  for my $line (<$handle>) {
    my $tmp_tmpl = $line_tmpl;
    my ($name, $inst_mac, $inst_netmask, $storage_type, $arch) = get_nodeinfo($line);
    if (grep /$name/, @{$hash->{EXCLUDE_LIST}}) {
      push @excluded, $name;
      next;
    }
    if (!defined $inst_mac) {
      push @mac_unknown, $name;
      next;
    }
    push @install_netmask_list, $inst_netmask;
    # Check storage configuration file
    my ($storage_conf_result, $storage_conf_path) = check_storage($storage_type);
    if ($storage_conf_result ne q|OK|) {
      print STDERR q|!!! ERROR !!! |, $storage_conf_result, $/;
      return 0;
    }
    # arch
    push @archs, $arch;
    # Get IP address by netmask and MAC Address
    my $inst_ip_address = get_ip_address($name, $inst_netmask, $inst_mac);
    if (!defined $inst_ip_address) {
      print STDERR q|!!! ERROR !!! |, qq|Can't find IP Address for $name corresponding netmask and MAC address|, $/;
      return 0;
    }
    # Replace Templates
    $tmp_tmpl =~ s/NODENAME/$name/;
    $tmp_tmpl =~ s/MAC/$inst_mac/;
    $tmp_tmpl =~ s/STORAGE_CONF/$storage_conf_path/;
    $tmp_tmpl =~ s/NETMASK/$inst_netmask/;
    $tmp_tmpl =~ s/IP_ADDRESS/$inst_ip_address/;
    $tmp_tmpl = qq|"$tmp_tmpl" \\\n|;
    push @node_lines, $tmp_tmpl;
  }
  close $handle;

  # Check install netmask
  my ($install_netmask_result, $install_netmask) = check_netmask(\@install_netmask_list);
  if ($install_netmask_result ne q|OK|) {
    print STDERR q|!!! ERROR !!! |, $install_netmask_result, $/;
    return 0;
  }
  # Check secret file
  if ($check_secret_file and ! -f $secret_file) {
    print STDERR q|!!! ERROR !!! |, q|Secret file doesn't exist at |, $secret_file, $/;
    return 0;
  }
  # Check architechture
  my ($arch_result) = check_arch(\@archs);
  if ($arch_result ne q|OK|) {
    print STDERR q|!!! ERROR !!! |, $arch_result, $/;
    return 0;
  }
  my $inst_kernel = select_install_kernel($archs[0]);
  my $linux_kernel = select_linux_kernel($archs[0]);
  if (!defined $inst_kernel or !defined $linux_kernel) {
    print q|Unknown architechture (|, $archs[0], q|): abort|, $/;
    return 0;
  }

  # OUTPUT
  my $nl = node_lines(\@node_lines);
  chomp $nl;
  $glbl_tmpl =~ s/LINE_TMPLS/$nl/;
  $glbl_tmpl =~ s/INSTALL_NETMASK/$install_netmask/;
  $glbl_tmpl =~ s/REMOTE_LDB_REPOSITORY_TYPE/$remote_ldb_repository_type/;
  $glbl_tmpl =~ s/REMOTE_LDB_REPOSITORY_LOCATION/$remote_ldb_repository/;
  $glbl_tmpl =~ s/SECRET_FILE/$secret_file/;
  $glbl_tmpl =~ s/INSTALL_KERNEL/$inst_kernel/;
  $glbl_tmpl =~ s/LINUX_KERNEL/$linux_kernel/;
  print $glbl_tmpl;

  if (@excluded != 0) {
    print qq|# Excluded List:\n|;
    print qq|# @excluded\n|;
  }
  if (@mac_unknown != 0) {
    print qq|# Unknown List:\n|;
    print qq|# @mac_unknown\n|;
  }

}

# Check Argv
sub check_argv{
  my %a = ();
  my ($start_node, $end_node);
  my $help;
  my @exclude;
  GetOptions("start-node=s" => \$start_node, "end-node=s" => \$end_node,
             "exclude:s{,}" => \@exclude, "help!" => \$help);
  if (defined $help and $help = 1) {
    usage();
    exit(0);
  }
  if (!defined $start_node or !defined $end_node) {
    usage();
    exit(0);
  }
  
  $a{START_NODE} = $start_node;
  $a{END_NODE} = $end_node;
  $a{EXCLUDE_LIST} = \@exclude;
  return \%a;
}

my $hash = check_argv();
main($hash);
