#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use Data::Dumper;

# Debug ?
my $DEBUG = 1;

###################################################################
#################### CONFIGURATION BEGINS HERE ####################
###################################################################

my $ldb_repos = q|/home/kabe/git/L4|;
my $secret_file = q|~/lucie/env.enc|;
my $remote_ldb_repository_type = q|Subversion|;
my $remote_ldb_repository = q|svn+ssh://intri@www.intrigger.jp/home/intri/SVN/L4|;

###################################################################
##################### CONFIGURATION ENDS HERE #####################
###################################################################

# Templates
my $cluster_select_sql = q|select name, mgmt_mac, mgmt_netmask, storage_conf_type, arch from host where name>="START_NODE" and name<="END_NODE"|;
my $line_tmpl = q|NODENAME --mac MAC --storage-conf STORAGE_CONF|;
my $glbl_tmpl = <<'END';
#/bin/sh

./node install-multi \
LINE_TMPLS
--netmask INSTALL_NETMASK \
--source-control REMOTE_LDB_REPOSITORY_TYPE \
--ldb-repository REMOTE_LDB_REPOSITORY_LOCATION \
--verbose \
-i INSTALL_KERNEL \
-l LINUX_KERNEL \
--secret SECRET_FILE
END

# Usage
sub usage {
  print << "EOD";
Usage :
 \$ $0 --start-node S_NODE --end-node E_NODE --exclude EXCLUDE1 EXCLUDE2 ...

  S_NODE   : NODE FROM (e.g. hongo100)
  E_NODE   : NODE TO   (e.g. hongo402)
  EXCLUDEn : NODEs to be excluded from the range (e.g. hongo105 hongo107)

Run Example :
 \$ $0 --start-node sheep00 --end-node sheep64 --exclude sheep02 sheep04 sheep07 sheep34 sheep46 sheep47

EOD
}

# Setup
my $storage_dir = $ldb_repos . q|/lucie/storage|;
my $check_secret_file = 1;
if ($DEBUG) {
  $check_secret_file = 0;
}

# Util
sub get_nodeinfo {
  my $line = shift;
  chomp $line;
  my ($name, $inst_mac, $inst_netmask, $storage_type, $arch) = split(/\|/, $line);
  $inst_mac = undef if $inst_mac eq "";
  $inst_netmask = undef if $inst_netmask eq "";
  $storage_type = undef if $storage_type eq "";
  $arch = undef if $arch eq "";
  return ($name, $inst_mac, $inst_netmask, $storage_type, $arch);
}

sub sql_cmd {
  my $hash = shift;
  my $start_node = $hash->{START_NODE};
  my $end_node = $hash->{END_NODE};
  my $repos = $ldb_repos;
  my $suf = q|bin/ldb sql|;
  $cluster_select_sql =~ s/'/\\'/;
  my $cmd = qq|$repos/$suf '$cluster_select_sql'|;
  $cmd =~ s/START_NODE/$start_node/;
  $cmd =~ s/END_NODE/$end_node/;
  return $cmd;
}

sub node_lines {
  my $aref = shift;
  my $str = "";
  for my $line (@$aref) {
    $str .= $line;
  }
  return $str;
}

# Check storage.conf's existence
# Return "OK" if everything is OK
sub check_storage {
  my $storage_type = shift; # Reference to the list of the names of storage.conf
  # File existence
  my $storage_conf_file_path = $storage_dir . '/' . $storage_type;
  if (! -f qq|$storage_conf_file_path|) {
    return qq|Storage configuration file ($storage_conf_file_path) not exists!|;
  }
  return (q|OK|, $storage_conf_file_path);
}

# Check array consistency
# Returns:
# $s[0] when all members are defined and consistent
# undef when a part of the member(s) is(are) undefined
# 0 when members of the array are not consistent
sub check_array_consistency {
  my $aref = shift;
  my @s = sort @$aref;
  return undef; if (!defined $s[0]);
  return 0 if ($s[0] ne $s[$#s]);
  return $s[0];
}

# Print Error and Exit
# (error type, additional message)
sub error {
  my $error_type = shift;
  my $additional_msg = shift | "";
  my $tmpl;
  if ($error_type = undef) { # undefined
    $tmpl = q|Undefined|;
  } elsif ($error_type = 0) { # inconsistent
    $tmpl = q|Inconsistent|;
  } elsif ($error_type = 1) { # invalid
    $tmpl = q|Invalid|
  } else { # unknown
    $tmpl = q|Unknown|;
  }
  printf STDERR q|!!! ERROR !!! %s : %s|, $tmpl, $additional_msg;
  exit(1);
}

sub check_netmask {
  my $aref = shift;
  my $ret = check_array_consistency($aref);
  if (!defined $ret) {
    error(undef, q|Install Netmask for some node(s) undefined!|);
  }
  if (!$ret) {
    error(1, q|Some of the install netmask configuration differs!|);
  }
  return (q|OK|, $s[0]);
}

sub check_arch {
  my $aref = shift;
  my $ret = check_array_consistency($aref);
  if (!defined $ret) {
    error(undef, q|Install Kernel for some node(s) undefined!|)
  } elsif (!$ret) {
    error(1, q|Some of the arch configuration differs!|);
  }
  return q|OK|;
}

sub select_install_kernel {
  my $arch = shift;
  if ($arch eq 'x86_64') {
    return q|linux-image-2.6.18_hongo.installer.20090714_amd64.deb|;
  } elsif ($arch eq 'i686') {
    return q|linux-image-2.6.18-fai-kernels_1_i386.deb|;
  } else {
    return q||;
  }
}

sub select_linux_kernel {
  my $arch = shift;
  if ($arch eq 'x86_64') {
    return q|linux-image-amd64|;
  } elsif ($arch eq 'i686') {
    return q|linux-image-686|;
  } else {
    return q||;
  }
}

sub main {
  my $hash = shift;
  my @node_lines = ();
  my @mac_unknown = ();
  my @excluded = ();
  my @install_netmask_list = ();
  my @archs = ();
  my $handle = undef;
  # Create SQL Command
  open $handle, sql_cmd($hash) . " | " or die "Can't open L4 pipe";
  for my $line (<$handle>) {
    my $tmp_tmpl = $line_tmpl;
    my ($name, $inst_mac, $inst_netmask, $storage_type, $arch) = get_nodeinfo($line);
    if (grep /$name/, @{$hash->{EXCLUDE_LIST}}) {
      push @excluded, $name;
      next;
    }
    if (!defined $inst_mac) {
      push @mac_unknown, $name;
      next;
    }
    push @install_netmask_list, $inst_netmask;
    # Check storage configuration file
    my ($storage_conf_result, $storage_conf_path) = check_storage($storage_type);
    if ($storage_conf_result ne q|OK|) {
      print STDERR q|!!! ERROR !!! |, $storage_conf_result, $/;
      return 0;
    }
    # arch
    push @archs, $arch;
    # Replace Templates
    $tmp_tmpl =~ s/NODENAME/$name/;
    $tmp_tmpl =~ s/MAC/$inst_mac/;
    $tmp_tmpl =~ s/STORAGE_CONF/$storage_conf_path/;
    $tmp_tmpl = qq|"$tmp_tmpl" \\\n|;
    push @node_lines, $tmp_tmpl;
  }
  close $handle;

  # Check install netmask
  my ($install_netmask_result, $install_netmask) = check_netmask(\@install_netmask_list);
  if ($install_netmask_result ne q|OK|) {
    print STDERR q|!!! ERROR !!! |, $install_netmask_result, $/;
    return 0;
  }
  # Check secret file
  if ($check_secret_file and ! -f $secret_file) {
    print STDERR q|!!! ERROR !!! |, q|Secret file doesn't exist at |, $secret_file, $/;
    return 0;
  }
  # Check architechture
  check_arch(\@archs);
  my $inst_kernel = select_install_kernel($archs[0]);
  my $linux_kernel = select_linux_kernel($archs[0]);
  if (!defined $inst_kernel or !defined $linux_kernel) {
    print q|Unknown architechture (|, $archs[0], q|): abort|, $/;
    return 0;
  }

  # OUTPUT
  my $nl = node_lines(\@node_lines);
  chomp $nl;
  $glbl_tmpl =~ s/LINE_TMPLS/$nl/;
  $glbl_tmpl =~ s/INSTALL_NETMASK/$install_netmask/;
  $glbl_tmpl =~ s/REMOTE_LDB_REPOSITORY_TYPE/$remote_ldb_repository_type/;
  $glbl_tmpl =~ s/REMOTE_LDB_REPOSITORY_LOCATION/$remote_ldb_repository/;
  $glbl_tmpl =~ s/SECRET_FILE/$secret_file/;
  $glbl_tmpl =~ s/INSTALL_KERNEL/$inst_kernel/;
  $glbl_tmpl =~ s/LINUX_KERNEL/$linux_kernel/;
  print $glbl_tmpl;

  if (@excluded != 0) {
    print qq|# Excluded List:\n|;
    print qq|# @excluded\n|;
  }
  if (@mac_unknown != 0) {
    print qq|# Unknown List:\n|;
    print qq|# @mac_unknown\n|;
  }

}

# Check Argv
sub check_argv{
  my %a = ();
  my ($start_node, $end_node);
  my $help;
  my @exclude;
  GetOptions("start-node=s" => \$start_node, "end-node=s" => \$end_node,
             "exclude:s{,}" => \@exclude, "help!" => \$help);
  if (defined $help and $help = 1) {
    usage();
    exit(0);
  }
  if (!defined $start_node or !defined $end_node) {
    usage();
    exit(0);
  }
  
  $a{START_NODE} = $start_node;
  $a{END_NODE} = $end_node;
  $a{EXCLUDE_LIST} = \@exclude;
  return \%a;
}

my $hash = check_argv();
main($hash);
